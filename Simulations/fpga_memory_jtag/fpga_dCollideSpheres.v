
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module fpga_dCollideSpheres(

	//////////// CLOCK //////////
	CLOCK_50,
	CLOCK2_50,
	CLOCK3_50,

	//////////// KEY //////////
	KEY,
	SW
);

//=======================================================
//  PARAMETER declarations
//=======================================================


//=======================================================
//  PORT declarations
//=======================================================

//////////// CLOCK //////////
input 		          		CLOCK_50;
input 		          		CLOCK2_50;
input 		          		CLOCK3_50;

//////////// KEY //////////
input 		     [3:0]		KEY;
input 		          		SW;


//=======================================================
//  REG/WIRE declarations
//=======================================================

wire [31:0] rst_reg;
wire [31:0] x1_reg;
wire [31:0] y1_reg;
wire [31:0] z1_reg;
wire [31:0] r1_reg;
wire [31:0] x2_reg;
wire [31:0] y2_reg;
wire [31:0] z2_reg;
wire [31:0] r2_reg, g1c, g2c;
wire [31:0] outs [8:0];
wire [31:0] check1;
wire [31:0] check2;
wire [31:0] check3;
wire [31:0] check4;
wire key0;
wire ret_val, done_flag;
wire rst_data;
reg rst_wire;
/*
reg [31:0] counter = 31'b0;
reg [31:0] debug = 31'b0;
reg reset = 1'b1;
reg flag = 1'b0;
wire [31:0] countrdy;
wire rdyData;
// jtag signals
assign key0 = ~KEY[0];
wire [31:0] datain_mem_w;
wire [31:0] dataout_mem_w;
wire we_w;

reg [7:0] addressreg;*/

reg [31:0] inaddress;
reg [31:0] outaddress;
reg [31:0] debug;
reg flag = 1'b0;
reg flagDatain = 1'b0;
reg flagDataout = 1'b0;
wire [31:0] countrdy;
wire rdyData;
// jtag signals
wire [31:0] datain_mem_w;
wire [31:0] dataout1_mem_w;
wire [31:0] dataout2_mem_w;
wire [31:0] dataout3_mem_w;
wire [31:0] dataout4_mem_w;
wire [31:0] dataout5_mem_w;
wire [31:0] dataout6_mem_w;
wire [31:0] dataout7_mem_w;
wire [31:0] dataout8_mem_w;

reg [7:0] addressreg;

reg [31:0] mem_input [0:31];

reg cs_w;
reg we_w;

wire oe_w;
wire fm_w;
wire rstOut_w;
wire end_of_memory_w;

reg rstMemCtrl = 1'b1;

reg flagMemCtrlRst = 1'b1;

wire [31:0] outaddress_w;

//=======================================================
//  Structural coding
//=======================================================

jtag_tx_rdy jtag0(
	.out_data(datain_mem_w),
	.count(countrdy),
	.out_rdy(rdyData)
);

jtag_debug jtag1(
	.in_debug(outs[6])
);

rst_Ctrl rstCTRL(
	.cs(fm_w),
	.clk(CLOCK_50),
	.done_collide(done_w),
	.rstOut(rstOut_w),
	.rst(1'b1)
);

dCollideSpheres test0(
	.x1(dataout1_mem_w), 
	.y1(dataout2_mem_w), 
	.z1(dataout3_mem_w), 
	.r1(dataout4_mem_w), 
	.x2(dataout5_mem_w), 
	.y2(dataout6_mem_w), 
	.z2(dataout7_mem_w), 
	.r2(dataout8_mem_w), 	
	.cx(outs[0]), 
	.cy(outs[1]), 
	.cz(outs[2]), 
	.normalx(outs[3]), 
	.normaly(outs[4]), 
	.normalz(outs[5]), 
	.depth(outs[6]), 
	.g1(32'd1), 
	.g2(32'd1), 
	.ret(outs[7]), 
	.clk(CLOCK_50), 
	.rst(rstOut_w), 
	.done(done_w),
	.test(check1),
	.test2(check2),
	.test3(check3),
	.test4(check4)
);

//assign datain_mem_w = (flagzero) ? inaddress:0;
ram_sp_sr_sw memory(
	.clk(CLOCK_50)         , // Clock Input
	.addressin(inaddress)     , // Address Input
	.addressout(outaddress_w)     , // Address Output
	.datain(datain_mem_w)        , // Data bi-directional
	.dataout0(dataout1_mem_w),
	.dataout1(dataout2_mem_w),
	.dataout2(dataout3_mem_w),
	.dataout3(dataout4_mem_w),
	.dataout4(dataout5_mem_w),
	.dataout5(dataout6_mem_w),
	.dataout6(dataout7_mem_w),
	.dataout7(dataout8_mem_w),
	.cs(cs_w)          , // Chip Select
	.we(we_w)          , // Write Enable/Read Enable
	.oe(oe_w)          , // Output Enable
	.fm(fm_w)           // Output Enable
); 

memoryController memcontrol( 
		//.clk(CLK),
		.rst(),
		.fetch_data_ready(done_w),
		.end_of_memory(end_of_memory_w),
		.address(outaddress_w),
		.output_enable(oe_w)		
);

always @(posedge rdyData)
begin
	if(inaddress < 32)
		begin
		if(flagDatain == 0)
		begin
			flagDatain <= 1;
			we_w <= 1;
		end else
		begin
			inaddress <= inaddress + 1;
			flagDatain <= 0;
			we_w <= 0;
		end
	end else
	begin
		we_w <= 0;
	end

end	

/*
always @(posedge KEY[0])
begin
	//if (KEY[0])
	//begin
	//	counter <= 0;
	//end
	if(counter == 32'd7)
	begin
		counter <= 0;
	end else
	begin
		counter <= counter + 1;
	end
	//else
	//	counter <= counter;
	//if(rdyData)
	//	counter <= counter + 1;
end	
*/

endmodule
