//AUTHOR = FREDY ALVES
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module fpga_floatcalc_jtag(

	//////////// CLOCK //////////
	CLOCK_50,
	CLOCK2_50,
	CLOCK3_50,

	//////////// KEY //////////
	KEY 
);

//=======================================================
//  PARAMETER declarations
//=======================================================


//=======================================================
//  PORT declarations
//=======================================================

//////////// CLOCK //////////
input 		          		CLOCK_50;
input 		          		CLOCK2_50;
input 		          		CLOCK3_50;

//////////// KEY //////////
input 		     [3:0]		KEY;


//=======================================================
//  REG/WIRE declarations
//=======================================================


wire tck, tdi;
wire cdr, eldr, e2dr, pdr, sdr, udr, uir, cir, tms;
reg  tdo;
wire [2:0]ir_in; //IR command register
reg [31:0] input_a_reg; 
reg [31:0] input_b_reg; 


wire [31:0] output_z_wire;
wire output_z_ack_wire;
wire output_z_stb_wire;
wire input_a_ack_wire;
wire input_b_ack_wire;

//=======================================================
//  Structural coding
//=======================================================
adder add1(
	.input_a(32'b01000000010011001100110011001101),
	.input_b(input_b_reg),
	.input_a_stb(1'b1),
	.input_b_stb(1'b1),
	.output_z_ack(output_z_ack_wire),
	.clk(CLOCK_50),
	.rst(KEY[0]),
	.output_z(output_z_wire),
	.output_z_stb(output_z_stb_wire),
	.input_a_ack(input_a_ack_wire),
	.input_b_ack(input_b_ack_wire)
	);

myjtag myjtag_inst(
	.tdo (tdo),
	.tck (tck),
	.tdi (tdi),
	.ir_in(ir_in),
	.ir_out(),
	.virtual_state_cdr (cdr),
	.virtual_state_e1dr(e1dr),
	.virtual_state_e2dr(e2dr),
	.virtual_state_pdr (pdr),
	.virtual_state_sdr (sdr),
	.virtual_state_udr (udr),
	.virtual_state_uir (uir),
	.virtual_state_cir (cir)
	);
	
//data receiver
//shifts incoming data during PUSH command
reg [31:0]shift_dr_in;

always @(posedge tck)
	if(sdr && (ir_in==3'b001) )
		shift_dr_in <= { tdi, shift_dr_in[31:1] };

//data receiver
//write received data (during PUSH command) into LED register 
always @(posedge tck)
	if(udr && (ir_in==3'b001) )
		input_b_reg <= shift_dr_in;

//data sender
reg [31:0]shift_dr_out;
always @(posedge tck)
	if(cdr && (ir_in==3'b010) )
		//capture data for send during command POP
		shift_dr_out <= output_z_wire;
	else
	if(sdr && (ir_in==3'b010) )
		//shift out data durng command POP
		shift_dr_out <= { tdi, shift_dr_out[31:1] };

//pass or bypass data via tdo reg
always @*
begin
	case(ir_in)
	4'b001: tdo = shift_dr_in [0];
	4'b010: tdo = shift_dr_out[0];
	default:
			  tdo = tdi;
	endcase
end
	



endmodule
